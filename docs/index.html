<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!-- Disable zooming: -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<!-- TODO: read https://www.html5rocks.com/en/mobile/mobifying/#toc-meta-viewport -->

<head>
    <title>Emigui â€“ An experimental immediate mode GUI written in Rust</title>
    <style>
        html {
            /* Remove touch delay: */
            touch-action: manipulation;
        }

        body {
            background: #000000;
        }

        html,
        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script>
        // The `--no-modules`-generated JS from `wasm-bindgen` attempts to use
        // `WebAssembly.instantiateStreaming` to instantiate the wasm module,
        // but this doesn't work with `file://` urls. This example is frequently
        // viewed by simply opening `index.html` in a browser (with a `file://`
        // url), so it would fail if we were to call this function!
        //
        // Work around this for now by deleting the function to ensure that the
        // `no_modules.js` script doesn't have access to it. You won't need this
        // hack when deploying over HTTP.
        delete WebAssembly.instantiateStreaming;
    </script>

    <!-- this is the JS generated by the `wasm-bindgen` CLI tool -->
    <script src="example_wasm.js"></script>

    <script>
        // we'll defer our execution until the wasm is ready to go
        // here we tell bindgen the path to the wasm file so it can start
        // initialization and return to us a promise when it's done
        wasm_bindgen("./example_wasm_bg.wasm")
            .then(on_wasm_loaded)["catch"](console.error);
        // ----------------------------------------------------------------------------
        var g_wasm_app = null;

        function paint_gui(canvas, input) {
            if (g_wasm_app === null) {
                g_wasm_app = wasm_bindgen.new_webgl_gui("canvas", pixels_per_point());
            }

            let output = JSON.parse(wasm_bindgen.run_gui(g_wasm_app, JSON.stringify(input)));
            // console.log(`output: ${JSON.stringify(output)}`);
            document.body.style.cursor = from_emigui_cursor(output.cursor_icon);
            if (output.open_url) {
                window.open(output.open_url, "_self");
            }
        }

        function from_emigui_cursor(cursor) {
            if (cursor == "no_drop") { return "no-drop"; }
            else if (cursor == "not_allowed") { return "not-allowed"; }
            else if (cursor == "resize_nw_se") { return "nwse-resize"; }
            else if (cursor == "pointing_hand") { return "pointer"; }
            // TODO: more
            else {
                // default, help, pointer, progress, wait, cell, crosshair, text, alias, copy, move, grab, grabbing,
                return cursor;
            }
        }

        // ----------------------------------------------------------------------------
        var g_mouse_pos = null;
        var g_mouse_down = false;
        var g_is_touch = false;
        var g_scroll_delta_x = 0;
        var g_scroll_delta_y = 0;

        function pixels_per_point() {
            // return 1.0;
            return window.devicePixelRatio || 1.0;
        }

        function auto_resize_canvas(canvas) {
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            canvas.width = window.innerWidth * pixels_per_point();
            canvas.height = window.innerHeight * pixels_per_point();
        }

        function get_input(canvas) {
            var input = {
                mouse_down: g_mouse_down,
                mouse_pos: g_mouse_pos,
                scroll_delta: { x: -g_scroll_delta_x, y: -g_scroll_delta_y }, // TODO: standardize scroll direction
                screen_size: { x: window.innerWidth, y: window.innerHeight },
                pixels_per_point: pixels_per_point(),
                time: window.performance.now() / 1000.0,
            };
            g_scroll_delta_x = 0;
            g_scroll_delta_y = 0;
            return input;
        }

        function mouse_pos_from_event(canvas, event) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        // If true, paint at full framerate always.
        // If false, only paint on input.
        // TODO: if this is turned off we must turn off animations too (which hasn't been implemented yet).
        const ANIMATION_FRAME = true;

        function paint() {
            var canvas = document.getElementById("canvas");
            auto_resize_canvas(canvas);
            paint_gui(canvas, get_input(canvas));
        }

        function paint_and_schedule() {
            paint();
            if (ANIMATION_FRAME) {
                window.requestAnimationFrame(paint_and_schedule);
            }
        }

        function on_wasm_loaded() {
            var canvas = document.getElementById("canvas");
            var invalidate = function () {
                if (!ANIMATION_FRAME) {
                    paint();
                }
            };

            canvas.addEventListener("mousedown", function (event) {
                if (g_is_touch) { return; }
                g_mouse_pos = mouse_pos_from_event(canvas, event);
                g_mouse_down = true;
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });
            canvas.addEventListener("mousemove", function (event) {
                if (g_is_touch) { return; }
                g_mouse_pos = mouse_pos_from_event(canvas, event);
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });
            canvas.addEventListener("mouseup", function (event) {
                if (g_is_touch) { return; }
                g_mouse_pos = mouse_pos_from_event(canvas, event);
                g_mouse_down = false;
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });
            canvas.addEventListener("mouseleave", function (event) {
                if (g_is_touch) { return; }
                g_mouse_pos = null;
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });

            canvas.addEventListener("touchstart", function (event) {
                g_is_touch = true;
                g_mouse_pos = { x: event.touches[0].pageX, y: event.touches[0].pageY };
                g_mouse_down = true;
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });
            canvas.addEventListener("touchmove", function (event) {
                g_is_touch = true;
                g_mouse_pos = { x: event.touches[0].pageX, y: event.touches[0].pageY };
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });
            canvas.addEventListener("touchend", function (event) {
                g_is_touch = true;
                g_mouse_down = false; // First release mouse to click...
                update_gui()();
                g_mouse_pos = null; // ...remove hover effect
                update_gui()();
                event.stopPropagation();
                event.preventDefault();
            });

            canvas.addEventListener("wheel", function (event) {
                g_scroll_delta_x += event.deltaX;
                g_scroll_delta_y += event.deltaY;
                invalidate();
                event.stopPropagation();
                event.preventDefault();
            });

            if (!ANIMATION_FRAME) {
                window.addEventListener("load", invalidate);
                window.addEventListener("pagehide", invalidate);
                window.addEventListener("pageshow", invalidate);
                window.addEventListener("resize", invalidate);
            }

            paint_and_schedule();
        }
    </script>
    <!-- TODO: make this cover the entire screen, with resize and all -->
    <canvas id="canvas" width="1024" height="1024"></canvas>
</body>

</html>
